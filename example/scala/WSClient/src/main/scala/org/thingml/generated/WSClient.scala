/**
 * File generated by the ThingML IDE
 * /!\Do not edit this file/!\
 * In case of a bug in the generated code,
 * please submit an issue on our GitHub
 **/

package org.thingml.generated
import org.thingml.generated._
import org.sintef.smac._
import scala.annotation.elidable
import scala.annotation.elidable._
import org.thingml.utils.comm.SerializableTypes._
object Logger {
@elidable(MINIMUM)def debug(s : String) {println("DEBUG:" + s)}
@elidable(INFO)def info(s : String) {println("INFO:" + s)}
@elidable(WARNING)def warning(s : String) {println("WARNING:" + s)}
@elidable(SEVERE)def error(s : String) {println("ERROR:" + s)}
@elidable(MAXIMUM)def severe(s : String) {println("KERNEL PANIC:" + s)}
}
// Definition of Enumeration  WS_ERR
object WS_ERR_ENUM extends Enumeration {
	type WS_ERR_ENUM = Byte
val WS_ERR_CONNECTION_REFUSED : Byte = 0
}
// Definition of Enumeration  DigitalState
object DigitalState_ENUM extends Enumeration {
	type DigitalState_ENUM = Byte
val DIGITALSTATE_LOW : Byte = 0
val DIGITALSTATE_HIGH : Byte = 1
}
object OnMessage{ def getName = "onMessage" }
case class OnMessage(msg : String, override val name : String = OnMessage.getName) extends Event(name)/* with java.io.Serializable*/
object Stop_server{ def getName = "stop_server" }
case class Stop_server(override val name : String = Stop_server.getName) extends Event(name)/* with java.io.Serializable*/
object Send{ def getName = "send" }
case class Send(msg : String, override val name : String = Send.getName) extends Event(name)/* with java.io.Serializable*/
object Stop_client{ def getName = "stop_client" }
case class Stop_client(override val name : String = Stop_client.getName) extends Event(name)/* with java.io.Serializable*/
object Start_client{ def getName = "start_client" }
case class Start_client(override val name : String = Start_client.getName) extends Event(name)/* with java.io.Serializable*/
object Timer_cancel{ def getName = "timer_cancel" }
case class Timer_cancel(override val name : String = Timer_cancel.getName) extends Event(name)/* with java.io.Serializable*/
object OnError{ def getName = "onError" }
case class OnError(errorMsg : String, override val name : String = OnError.getName) extends Event(name)/* with java.io.Serializable*/
object Start_server{ def getName = "start_server" }
case class Start_server(override val name : String = Start_server.getName) extends Event(name)/* with java.io.Serializable*/
object Client_launched{ def getName = "client_launched" }
case class Client_launched(override val name : String = Client_launched.getName) extends Event(name)/* with java.io.Serializable*/
object Stop{ def getName = "stop" }
case class Stop(override val name : String = Stop.getName) extends Event(name)/* with java.io.Serializable*/
object Start{ def getName = "start" }
case class Start(override val name : String = Start.getName) extends Event(name)/* with java.io.Serializable*/
object Timer_timeout{ def getName = "timer_timeout" }
case class Timer_timeout(override val name : String = Timer_timeout.getName) extends Event(name)/* with java.io.Serializable*/
object OnClose{ def getName = "onClose" }
case class OnClose(override val name : String = OnClose.getName) extends Event(name)/* with java.io.Serializable*/
object Server_launched{ def getName = "server_launched" }
case class Server_launched(override val name : String = Server_launched.getName) extends Event(name)/* with java.io.Serializable*/
object Timer_start{ def getName = "timer_start" }
case class Timer_start(delay : Short, override val name : String = Timer_start.getName) extends Event(name)/* with java.io.Serializable*/
object OnOpen{ def getName = "onOpen" }
case class OnOpen(override val name : String = OnOpen.getName) extends Event(name)/* with java.io.Serializable*/

/**
 * Definitions for type : Test
 **/
class Test() extends Component {

//Companion object
object Test{
object timerPort{
def getName = "timer"
object in {
val timer_timeout_i = Timer_timeout.getName
}
object out {
val timer_start_o = Timer_start.getName
val timer_cancel_o = Timer_cancel.getName
}
}

object lifecyclePort{
def getName = "lifecycle"
object in {
val onOpen_i = OnOpen.getName
val onClose_i = OnClose.getName
val server_launched_i = Server_launched.getName
val client_launched_i = Client_launched.getName
}
object out {
val start_o = Start.getName
val stop_o = Stop.getName
val start_client_o = Start_client.getName
val start_server_o = Start_server.getName
val stop_client_o = Stop_client.getName
val stop_server_o = Stop_server.getName
}
}

object errPort{
def getName = "err"
object in {
val onError_i = OnError.getName
}
object out {
}
}

object messagingPort{
def getName = "messaging"
object in {
val onMessage_i = OnMessage.getName
}
object out {
val send_o = Send.getName
}
}

}

new Port(Test.timerPort.getName, List(Test.timerPort.in.timer_timeout_i), List(Test.timerPort.out.timer_start_o, Test.timerPort.out.timer_cancel_o), this).start
new Port(Test.lifecyclePort.getName, List(Test.lifecyclePort.in.onOpen_i, Test.lifecyclePort.in.onClose_i, Test.lifecyclePort.in.server_launched_i, Test.lifecyclePort.in.client_launched_i), List(Test.lifecyclePort.out.start_o, Test.lifecyclePort.out.stop_o, Test.lifecyclePort.out.start_client_o, Test.lifecyclePort.out.start_server_o, Test.lifecyclePort.out.stop_client_o, Test.lifecyclePort.out.stop_server_o), this).start
new Port(Test.errPort.getName, List(Test.errPort.in.onError_i), List(), this).start
new Port(Test.messagingPort.getName, List(Test.messagingPort.in.onMessage_i), List(Test.messagingPort.out.send_o), this).start
this.behavior ++= List(new BehaviorStateMachine(false, this).getBehavior)
case class BehaviorStateMachine(keepHistory : Boolean, root : Component) extends StateAction {
override def getBehavior = parent
val parent : StateMachine = new StateMachine(this, keepHistory, root)
override def onEntry() = {
Logger.debug("behavior.onEntry")
//No entry action defined for this state
}

override def onExit() = {
Logger.debug("behavior.onExit")
//No exit action defined for this state
}

new InternalTransition(getBehavior, new InternalTransition_behavior_2351415(), List((Test.lifecyclePort.getName, Test.lifecyclePort.in.onOpen_i)))
new InternalTransition(getBehavior, new InternalTransition_behavior_6023435(), List((Test.lifecyclePort.getName, Test.lifecyclePort.in.onClose_i)))
new InternalTransition(getBehavior, new InternalTransition_behavior_4716194(), List((Test.errPort.getName, Test.errPort.in.onError_i)))
new InternalTransition(getBehavior, new InternalTransition_behavior_21224643(), List((Test.messagingPort.getName, Test.messagingPort.in.onMessage_i)))
case class InternalTransition_behavior_2351415 extends InternalTransitionAction {
override def executeActions() = {
Logger.debug("t_self_behavior_2351415.executeActions")
Logger.info((("test::onOpen")).toString)
}

}
case class InternalTransition_behavior_6023435 extends InternalTransitionAction {
override def executeActions() = {
Logger.debug("t_self_behavior_6023435.executeActions")
Logger.info((("test::onClose")).toString)
}

}
case class InternalTransition_behavior_4716194 extends InternalTransitionAction {
override def executeActions() = {
Logger.debug("t_self_behavior_4716194.executeActions")
Logger.info((("test::onError")).toString)
}

}
case class InternalTransition_behavior_21224643 extends InternalTransitionAction {
override def executeActions() = {
Logger.debug("t_self_behavior_21224643.executeActions")
Logger.info((("test::onMessage" + getEvent(Test.messagingPort.in.onMessage_i, Test.messagingPort.getName).get.asInstanceOf[OnMessage].msg)).toString)
}

}
//create sub-states
private val _Loop_state = LoopState()
val Loop_state = new State(_Loop_state, root)
_Loop_state.init
parent.addSubState(Loop_state)
case class LoopState extends StateAction {
override def onEntry() = {
Logger.debug("Loop.onEntry")
handler.getPort("timer") match{
case Some(p) => p.send(new Timer_start(10000))
case None => Logger.warning("no port timer You may consider revising your ThingML model. Or contact the development team if you think it is a bug.")
}
}

override def onExit() = {
Logger.debug("Loop.onExit")
//No exit action defined for this state
}

def init {
}

}

parent.setInitial(Loop_state)

//create transitions among sub-states
val t_Loop2Loop_17497870 = new Transition(Loop_state, Loop_state, new TransitionLoop2Loop_17497870(), List((Test.timerPort.getName, Test.timerPort.in.timer_timeout_i)))
parent.addTransition(t_Loop2Loop_17497870)
case class TransitionLoop2Loop_17497870 extends TransitionAction {
override def executeActions() = {
Logger.debug("t_Loop2Loop_17497870.executeActions")
Logger.info((("sending ping...")).toString)
handler.getPort("messaging") match{
case Some(p) => p.send(new Send("ping..."))
case None => Logger.warning("no port messaging You may consider revising your ThingML model. Or contact the development team if you think it is a bug.")
}
}

}
}
}

/**
 * Definitions for type : WebSocketClientScala
 **/
class WebSocketClientScala(private var _WebSocketClientScala_client_var : org.thingml.utils.WSClient, private var _WebSocketClientScala_status_var : Byte, val WebSocket__port_var : String) extends Component with org.thingml.utils.WSClientObserver{

//Synchronized accessors of client:org.thingml.utils.WSClient
def WebSocketClientScala_client_var:org.thingml.utils.WSClient = {synchronized{return _WebSocketClientScala_client_var}}
def WebSocketClientScala_client_var_=(newValue : org.thingml.utils.WSClient) { synchronized{ _WebSocketClientScala_client_var = newValue}}

//Synchronized accessors of status:Byte
def WebSocketClientScala_status_var:Byte = {synchronized{return _WebSocketClientScala_status_var}}
def WebSocketClientScala_status_var_=(newValue : Byte) { synchronized{ _WebSocketClientScala_status_var = newValue}}

//Companion object
object WebSocketClientScala{
object lifecyclePort{
def getName = "lifecycle"
object in {
val start_i = Start.getName
val stop_i = Stop.getName
val start_client_i = Start_client.getName
val start_server_i = Start_server.getName
val stop_client_i = Stop_client.getName
val stop_server_i = Stop_server.getName
}
object out {
val onOpen_o = OnOpen.getName
val onClose_o = OnClose.getName
val server_launched_o = Server_launched.getName
val client_launched_o = Client_launched.getName
}
}

object errPort{
def getName = "err"
object in {
}
object out {
val onError_o = OnError.getName
}
}

object messagingPort{
def getName = "messaging"
object in {
val send_i = Send.getName
}
object out {
val onMessage_o = OnMessage.getName
}
}

}

new Port(WebSocketClientScala.lifecyclePort.getName, List(WebSocketClientScala.lifecyclePort.in.start_i, WebSocketClientScala.lifecyclePort.in.stop_i, WebSocketClientScala.lifecyclePort.in.start_client_i, WebSocketClientScala.lifecyclePort.in.start_server_i, WebSocketClientScala.lifecyclePort.in.stop_client_i, WebSocketClientScala.lifecyclePort.in.stop_server_i), List(WebSocketClientScala.lifecyclePort.out.onOpen_o, WebSocketClientScala.lifecyclePort.out.onClose_o, WebSocketClientScala.lifecyclePort.out.server_launched_o, WebSocketClientScala.lifecyclePort.out.client_launched_o), this).start
new Port(WebSocketClientScala.errPort.getName, List(), List(WebSocketClientScala.errPort.out.onError_o), this).start
new Port(WebSocketClientScala.messagingPort.getName, List(WebSocketClientScala.messagingPort.in.send_i), List(WebSocketClientScala.messagingPort.out.onMessage_o), this).start
override def onOpen() : Unit = {
Logger.debug("Executing onOpen ...")
val handler = this
handler.getPort("lifecycle") match{
case Some(p) => p.send(new OnOpen())
case None => Logger.warning("no port lifecycle You may consider revising your ThingML model. Or contact the development team if you think it is a bug.")
}
}
override def onClose() : Unit = {
Logger.debug("Executing onClose ...")
val handler = this
handler.getPort("lifecycle") match{
case Some(p) => p.send(new OnClose())
case None => Logger.warning("no port lifecycle You may consider revising your ThingML model. Or contact the development team if you think it is a bug.")
}
}
override def onError(WebSocketClientScala_onError_msg_var : String) : Unit = {
Logger.debug("Executing onError ...")
val handler = this
handler.getPort("err") match{
case Some(p) => p.send(new OnError(WebSocketClientScala_onError_msg_var))
case None => Logger.warning("no port err You may consider revising your ThingML model. Or contact the development team if you think it is a bug.")
}
}
override def onMessage(WebSocketClientScala_onMessage_msg_var : String) : Unit = {
Logger.debug("Executing onMessage ...")
val handler = this
handler.getPort("messaging") match{
case Some(p) => p.send(new OnMessage(WebSocketClientScala_onMessage_msg_var))
case None => Logger.warning("no port messaging You may consider revising your ThingML model. Or contact the development team if you think it is a bug.")
}
if(WebSocketClientScala_onMessage_msg_var == "Connection refused: connect") {
WebSocketClientScala_status_var = (WS_ERR_ENUM.WS_ERR_CONNECTION_REFUSED).asInstanceOf[Byte]

}
}
this.behavior ++= List(new BehaviorStateMachine(false, this).getBehavior)
case class BehaviorStateMachine(keepHistory : Boolean, root : Component) extends StateAction {
override def getBehavior = parent
val parent : StateMachine = new StateMachine(this, keepHistory, root)
override def onEntry() = {
Logger.debug("behavior.onEntry")
//No entry action defined for this state
}

override def onExit() = {
Logger.debug("behavior.onExit")
//No exit action defined for this state
}

//create sub-states
private val _Init_state = InitState()
val Init_state = new State(_Init_state, root)
_Init_state.init
parent.addSubState(Init_state)
case class InitState extends StateAction {
override def onEntry() = {
Logger.debug("Init.onEntry")
Logger.info((("DEBUG3: " + WebSocket__port_var)).toString)
WebSocketClientScala_client_var = (new org.thingml.utils.WSClient(WebSocket__port_var, root.asInstanceOf[org.thingml.utils.WSClientObserver])).asInstanceOf[org.thingml.utils.WSClient]
}

override def onExit() = {
Logger.debug("Init.onExit")
//No exit action defined for this state
}

def init {
}

}

private val _Started_state = StartedState()
val Started_state = new State(_Started_state, root)
_Started_state.init
parent.addSubState(Started_state)
case class StartedState extends StateAction {
override def onEntry() = {
Logger.debug("Started.onEntry")
WebSocketClientScala_client_var.start();
}

override def onExit() = {
Logger.debug("Started.onExit")
//No exit action defined for this state
}

def init {
new InternalTransition(getBehavior, new InternalTransition_Started_4030604(), List((WebSocketClientScala.messagingPort.getName, WebSocketClientScala.messagingPort.in.send_i)))
}

case class InternalTransition_Started_4030604 extends InternalTransitionAction {
override def executeActions() = {
Logger.debug("t_self_Started_4030604.executeActions")
WebSocketClientScala_client_var.send(getEvent(WebSocketClientScala.messagingPort.in.send_i, WebSocketClientScala.messagingPort.getName).get.asInstanceOf[Send].msg+" from client "+WebSocketClientScala_client_var);
}

}
}

private val _Stopped_state = StoppedState()
val Stopped_state = new State(_Stopped_state, root)
_Stopped_state.init
parent.addSubState(Stopped_state)
case class StoppedState extends StateAction {
override def onEntry() = {
Logger.debug("Stopped.onEntry")
WebSocketClientScala_client_var.stop();
}

override def onExit() = {
Logger.debug("Stopped.onExit")
//No exit action defined for this state
}

def init {
}

}

parent.setInitial(Init_state)

//create transitions among sub-states
val t_Init2Started_18412270 = new Transition(Init_state, Started_state, new TransitionInit2Started_18412270(), List())
parent.addTransition(t_Init2Started_18412270)
val t_Started2Stopped_28333967 = new Transition(Started_state, Stopped_state, new TransitionStarted2Stopped_28333967(), List((WebSocketClientScala.lifecyclePort.getName, WebSocketClientScala.lifecyclePort.in.stop_i)))
parent.addTransition(t_Started2Stopped_28333967)
val t_Stopped2Started_30343003 = new Transition(Stopped_state, Started_state, new TransitionStopped2Started_30343003(), List((WebSocketClientScala.lifecyclePort.getName, WebSocketClientScala.lifecyclePort.in.start_i)))
parent.addTransition(t_Stopped2Started_30343003)
case class TransitionInit2Started_18412270 extends TransitionAction {
override def executeActions() = {
Logger.debug("t_Init2Started_18412270.executeActions")
//No action defined for this transition
}

}
case class TransitionStarted2Stopped_28333967 extends TransitionAction {
override def executeActions() = {
Logger.debug("t_Started2Stopped_28333967.executeActions")
//No action defined for this transition
}

}
case class TransitionStopped2Started_30343003 extends TransitionAction {
override def executeActions() = {
Logger.debug("t_Stopped2Started_30343003.executeActions")
//No action defined for this transition
}

}
}
}

/**
 * Definitions for type : TimerScala
 **/
class TimerScala(private var _TimerScala_scalaTimer_var : org.thingml.utils.timer.Timer) extends Component with org.thingml.utils.timer.TimerTask{

//Synchronized accessors of scalaTimer:org.thingml.utils.timer.Timer
def TimerScala_scalaTimer_var:org.thingml.utils.timer.Timer = {synchronized{return _TimerScala_scalaTimer_var}}
def TimerScala_scalaTimer_var_=(newValue : org.thingml.utils.timer.Timer) { synchronized{ _TimerScala_scalaTimer_var = newValue}}

//Companion object
object TimerScala{
object timerPort{
def getName = "timer"
object in {
val timer_start_i = Timer_start.getName
val timer_cancel_i = Timer_cancel.getName
}
object out {
val timer_timeout_o = Timer_timeout.getName
}
}

}

new Port(TimerScala.timerPort.getName, List(TimerScala.timerPort.in.timer_start_i, TimerScala.timerPort.in.timer_cancel_i), List(TimerScala.timerPort.out.timer_timeout_o), this).start
override def onTimeout() : Unit = {
Logger.debug("Executing onTimeout ...")
val handler = this
Logger.info((("timeout ")).toString)
handler.getPort("timer") match{
case Some(p) => p.send(new Timer_timeout())
case None => Logger.warning("no port timer You may consider revising your ThingML model. Or contact the development team if you think it is a bug.")
}
}
def cancel() : Unit = {
Logger.debug("Executing cancel ...")
val handler = this
Logger.info((("cancel ")).toString)
if( !((TimerScala_scalaTimer_var == null))) {
TimerScala_scalaTimer_var ! "cancel"

}
}
def start(TimerScala_start_delay_var : Short) : Unit = {
Logger.debug("Executing start ...")
val handler = this
Logger.info((("start " + TimerScala_start_delay_var)).toString)
cancel()
TimerScala_scalaTimer_var = (new org.thingml.utils.timer.Timer(this,TimerScala_start_delay_var).start).asInstanceOf[org.thingml.utils.timer.Timer]
}
this.behavior ++= List(new SoftTimerStateMachine(false, this).getBehavior)
case class SoftTimerStateMachine(keepHistory : Boolean, root : Component) extends StateAction {
override def getBehavior = parent
val parent : StateMachine = new StateMachine(this, keepHistory, root)
override def onEntry() = {
Logger.debug("SoftTimer.onEntry")
//No entry action defined for this state
}

override def onExit() = {
Logger.debug("SoftTimer.onExit")
//No exit action defined for this state
}

//create sub-states
private val _default_state = DefaultState()
val default_state = new State(_default_state, root)
_default_state.init
parent.addSubState(default_state)
case class DefaultState extends StateAction {
override def onEntry() = {
Logger.debug("default.onEntry")
//No entry action defined for this state
}

override def onExit() = {
Logger.debug("default.onExit")
//No exit action defined for this state
}

def init {
new InternalTransition(getBehavior, new InternalTransition_default_3648050(), List((TimerScala.timerPort.getName, TimerScala.timerPort.in.timer_start_i)))
new InternalTransition(getBehavior, new InternalTransition_default_6766442(), List((TimerScala.timerPort.getName, TimerScala.timerPort.in.timer_cancel_i)))
}

case class InternalTransition_default_3648050 extends InternalTransitionAction {
override def checkGuard() : Boolean = {
getEvent(TimerScala.timerPort.in.timer_start_i, TimerScala.timerPort.getName).get.asInstanceOf[Timer_start].delay > 0
}
override def executeActions() = {
Logger.debug("t_self_default_3648050.executeActions")
start((getEvent(TimerScala.timerPort.in.timer_start_i, TimerScala.timerPort.getName).get.asInstanceOf[Timer_start].delay).toShort)
}

}
case class InternalTransition_default_6766442 extends InternalTransitionAction {
override def executeActions() = {
Logger.debug("t_self_default_6766442.executeActions")
cancel()
}

}
}

parent.setInitial(default_state)

//create transitions among sub-states
}
}

// Initialize instance variables and states

